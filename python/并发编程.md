#### 多任务

> 三种方式：
>
> - 多进程模式
> - 多线程模式
> - 多进程+多线程模式
>
> 线程是最小执行单元，进程至少由一个线程组成，如何调度进程和线程完全由操作系统决定。
>
> 多进程和多线程涉及到同步、数据共享问题。

#### 多进程（multiprocessing)

> Unix/Linux提供一个`fork()`系统调用，调用一次返回两次，操作系统自动把当前进程（父进程）复制了一份（子进程），然后分别在父进程和子进程返回。
>
> 子进程永远返回`0`，父进程则返回子进程的`id`。父进程可以`fork`很多子进程，所以必须记下每个子进程的`id`，而子进程只需要调用`getppid()`就可获得父进程`id`

- `os`模块封装了系统调用`fork`（仅在Unix/Linux内核系统下）

  ```python
  import os
  
  print('Process (%s) start...' % os.getpid())
  
  pid = os.fork()
  if pi == 0:
      print('I am child process (%s) and my parent is (%s)' % (os.getpid(), os.getppid()))
  else:
      print('I (%s) just created a child process (%s)' % (os.getpid(), pid))
  ```

  ```shell
  运行结果：
  Process (142) start ...
  I (142) just created a child process (143).
  I am child process (143) and my parent is (142).
  ```

- `multiprocessing`模块提供跨平台的多进程服务。

  - `multiprocessing.Process`类代表一个进程对象

    ```python
    from multiprocessing import Process
    import os
    
    def run_proc(name):
        print('Run child process %s (%s)...' % (name, os.getpid()))
        
    if __name__ == '__main__':
        print('Process parent %s.' % os.getpid())
        p = Process(target=run_porc, args=('test',))
        print('Child process will start.')
        p.start()
        p.join()
        print('Child process end.')
    ```

  - `multiprocessing.Pool`创建进程池

    ```python
    from multiprocessing import Pool
    import os, time, random
    
    def long_time_task(name):
        print('Run task %s (%s)...' % (name, os.getpid()))
        start = time.time()
        time.sleep(random.random() * 3)
        end = time.time()
        print('Task %s runs %0.2f seconds' % (name, (end - start)))
        
    if __name__ == '__main__':
        print('Parent process %s.' % os.getpid())
        p = Pool(4)
        for i in range(5):
            p.apply_async(long_time_task, args=(i,))
        print('Waiting for all subprocesses done...')
        p.close()
        p.join()
        print('All subprocesses done.')
    
    ```

    

