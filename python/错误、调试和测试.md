#### 错误处理

> 错误码：函数返回值，易与正常返回值混淆，且一级一级向上报
>
> 错误处理机制：高级语言内置的`try...except...finally...`
>
> `Python`语言为`try...except...[else...][finally...]`

#####  跨越多层调用

```python

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    while True:
        x = int(input('x:'))
        try:
            y = bar(x)
        except Exception as e:
            print('Error:', e)
        else:
            print(y)
        finally:
            print('finally...')

main()
```

##### 通过分析错误的调用栈信息定位错误的位置。

```python
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar('0')

main()
```

上诉代码没有异常处理机制，出现异常会如下所示：

```python
Traceback (most recent call last):
  File "except2.py", line 10, in <module>
    main()
  File "except2.py", line 8, in main
    bar('0')
  File "except2.py", line 5, in bar
    return foo(s) * 2
  File "except2.py", line 2, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
```

##### 通过`logging`把错误记叙到日志文件中，便于事后排查

```python

import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        y = bar('0')
    except Exception as e:
        logging.exception(e)

main()
print('END')
```

输出：

```python
ERROR:root:division by zero
Traceback (most recent call last):
  File "except3.py", line 12, in main
    y = bar('0')
  File "except3.py", line 8, in bar
    return foo(s) * 2
  File "except3.py", line 5, in foo
    return 10 / int(s)
ZeroDivisionError: division by zero
END
```

##### 自定义错误

```python
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n == 0:
        raise FooError('invalid value %s' %s)
    return 10 / n

foo('0')
```

输出：

```python
Traceback (most recent call last):
  File "except4.py", line 11, in <module>
    foo('0')
  File "except4.py", line 8, in foo
    raise FooError('invalid value %s' %s)
__main__.FooError: invalid value 0
```

尽量使用`Python`内置的错误类型。

##### `raise`向上抛出错误

```python
def foo(s):
    n = int(s)
    if n == 0:
        raise ValueError('invalid value %s' %s)
    return n / 10

def bar():
    try:
        foo('0')
    except ZeroDivisionError as e:
        print('ZeroDivisionError')
        raise	
        # raise ValueError

bar()
```

不带参数抛出原样错误，也可以抛出其他类型的错误，确保逻辑合理